// Generated by VeGen. Do not edit.

function h<K extends keyof HTMLElementTagNameMap>(
  tag: K,
  props: Partial<HTMLElementTagNameMap[K]> = {},
  children: Node[] = [],
  dataset: Record<string, string> = {}
): HTMLElementTagNameMap[K] {
  const element = document.createElement(tag);
  Object.assign(element, props);
  Object.assign(element.dataset, dataset);
  element.append(...children);
  return element;
}
const t = (s: string) => document.createTextNode(s);

// Pipeline functions
function numberToString(value: number): string {
  return value.toString();
}
function boolean<T>(value: boolean, t: T, f: T): T {
  return value ? t : f;
}
type ViewState<Input> = {
  root: any;
  update: (input: Input) => void;
};
type View<Input> = (input: Input) => ViewState<Input>;
function updateForLoop<Input>({
  anchor,
  prevStates,
  nextInputs,
  subView,
}: {
  anchor: Comment;
  prevStates: ViewState<Input>[];
  nextInputs: Input[];
  subView: View<Input>;
}) {
  const parent = anchor.parentNode!;
  let states = prevStates.slice();

  // Remove extra items (from end, working backwards)
  while (states.length > nextInputs.length) {
    const removed = states.pop()!;
    parent.removeChild(removed.root);
  }

  // Update existing items
  for (let i = 0; i < Math.min(states.length, nextInputs.length); i++) {
    states[i].update(nextInputs[i]);
  }

  // Add new items (insert before anchor)
  for (let i = states.length; i < nextInputs.length; i++) {
    const state = subView(nextInputs[i]);
    parent.insertBefore(state.root, anchor);
    states.push(state);
  }

  return states;
}
export function run<Input>(
  view: View<Input>,
  buildComponent: (get: () => Input, set: (newInput: Input) => void) => Input
): Element {
  let state: ViewState<Input>;
  let currentInput: Input;

  const get = () => currentInput;

  const set = (newInput: Input) => {
    currentInput = newInput;
    state.update(newInput);
  };

  // Build the initial input and state
  currentInput = buildComponent(get, set);
  state = view(currentInput);

  return state.root;
}
export type NestedForInput = { addBar: (this: GlobalEventHandlers, ev: MouseEvent) => any, addFoo: (this: GlobalEventHandlers, ev: MouseEvent) => any, bars: string[], foos: string[] };
export function nestedFor(input: NestedForInput): ViewState<NestedForInput> {
  const child0: View<any> = (input) => {
    const child0: View<any> = (input) => {
      const node0 = t(input.foo);
      const node1 = t(input.bar);
      const node2 = h("div", {"id": `${input.foo}${input.bar}`, "className": "card"}, [node0, t(" - "), node1]);
      const root = node2;
      let currentInput = input;
      return {
        root,
        update(input) {
          if (input.bar !== currentInput.bar) {
            node1.textContent = input.bar;
          }
          if (input.bar !== currentInput.bar || input.foo !== currentInput.foo) {
            node2["id"] = `${input.foo}${input.bar}`;
          }
          if (input.foo !== currentInput.foo) {
            node0.textContent = input.foo;
          }
          currentInput = input;
        }
      };
    };
    const anchor0 = document.createComment("for-loop-0");
    const loopElements0 = [];
    let childState0: any[] = [];
    for (const item of input.bars) {
      const itemState = child0({ ...input, bar: item });
      loopElements0.push(itemState.root);
      childState0.push(itemState);
    }
    loopElements0.push(anchor0);
    const root = h("div", {"className": "flex"}, [...loopElements0]);
    let currentInput = input;
    return {
      root,
      update(input) {
        childState0 = updateForLoop({
          anchor: anchor0,
          prevStates: childState0,
          nextInputs: input.bars.map((bar: any) => ({ ...input, bar })),
          subView: child0
        });
        currentInput = input;
      }
    };
  };
  const anchor0 = document.createComment("for-loop-0");
  const loopElements0 = [];
  let childState0: any[] = [];
  for (const item of input.foos) {
    const itemState = child0({ ...input, foo: item });
    loopElements0.push(itemState.root);
    childState0.push(itemState);
  }
  loopElements0.push(anchor0);
  const node0 = h("button", {"onclick": input.addFoo}, [t("+ Add Foo")]);
  const node1 = h("button", {"onclick": input.addBar}, [t("+ Add Bar")]);
  const root = h("div", {"className": "container"}, [h("div", {"className": "controls"}, [node0, node1]), h("div", {"className": "flex-column"}, [...loopElements0])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.addBar !== currentInput.addBar) {
        node1["onclick"] = input.addBar;
      }
      if (input.addFoo !== currentInput.addFoo) {
        node0["onclick"] = input.addFoo;
      }
      childState0 = updateForLoop({
        anchor: anchor0,
        prevStates: childState0,
        nextInputs: input.foos.map((foo: any) => ({ ...input, foo })),
        subView: child0
      });
      currentInput = input;
    }
  };
}
export type CounterInput = { count: number, decrement: (this: GlobalEventHandlers, ev: MouseEvent) => any, increment: (this: GlobalEventHandlers, ev: MouseEvent) => any };
export function counter(input: CounterInput): ViewState<CounterInput> {
  const node0 = t(numberToString(input.count));
  const node1 = h("button", {"onclick": input.increment}, [t("+ Increment")]);
  const node2 = h("button", {"onclick": input.decrement}, [t("- Decrement")]);
  const root = h("div", {"className": "container"}, [h("div", {"className": "display"}, [t("Count: "), node0]), h("div", {"className": "controls"}, [node1, node2])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.count !== currentInput.count) {
        node0.textContent = numberToString(input.count);
      }
      if (input.decrement !== currentInput.decrement) {
        node2["onclick"] = input.decrement;
      }
      if (input.increment !== currentInput.increment) {
        node1["onclick"] = input.increment;
      }
      currentInput = input;
    }
  };
}
export type ComponentInput = { counter: () => Element, total: number };
export function component(input: ComponentInput): ViewState<ComponentInput> {
  const mountedElement0 = input.counter();
  const mountedElement1 = input.counter();
  const node0 = t(numberToString(input.total));
  const root = h("div", {"className": "container"}, [h("div", {"className": "grid"}, [mountedElement0, mountedElement1]), h("div", {"className": "highlight"}, [t("\n      Total Count: "), node0, t("\n    ")])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.total !== currentInput.total) {
        node0.textContent = numberToString(input.total);
      }
      currentInput = input;
    }
  };
}
export type UseTestInput = { counter0: CounterInput, counter1: CounterInput };
export function useTest(input: UseTestInput): ViewState<UseTestInput> {
  const useViewState0 = counter(input.counter0);
  const useViewElement0 = useViewState0.root;
  const useViewState1 = counter(input.counter1);
  const useViewElement1 = useViewState1.root;
  const root = h("div", {"className": "container"}, [useViewElement0, useViewElement1]);
  let currentInput = input;
  return {
    root,
    update(input) {
      useViewState0.update(input.counter0);
      useViewState1.update(input.counter1);
      currentInput = input;
    }
  };
}
export type IfTestInput = { a: { b: { c: string } }, show: boolean, toggle: (this: GlobalEventHandlers, ev: MouseEvent) => any, x: { y: { z: string } } };
export function ifTest(input: IfTestInput): ViewState<IfTestInput> {
  const child0: View<any> = (input) => {
    const node0 = t(input.a.b.c);
    const root = h("div", {"id": "shown"}, [t("Now you see me! "), node0]);
    let currentInput = input;
    return {
      root,
      update(input) {
        if (input.a.b.c !== currentInput.a.b.c) {
          node0.textContent = input.a.b.c;
        }
        currentInput = input;
      }
    };
  };
  const child1: View<any> = (input) => {
    const node0 = t(input.x.y.z);
    const root = h("div", {"id": "hidden"}, [t("Now you don't! "), node0]);
    let currentInput = input;
    return {
      root,
      update(input) {
        if (input.x.y.z !== currentInput.x.y.z) {
          node0.textContent = input.x.y.z;
        }
        currentInput = input;
      }
    };
  };
  const conditionalElements0 = [];
  let currentRoot0: any;
  if (input.show) {
    const thenState = child0(input);
    currentRoot0 = thenState.root;
    conditionalElements0.push(currentRoot0);
  } else {
    const elseState = child1(input);
    currentRoot0 = elseState.root;
    conditionalElements0.push(currentRoot0);
  }
  const node0 = h("button", {"onclick": input.toggle}, [t("Toggle")]);
  const root = h("div", {"className": "container"}, [h("div", {"className": "controls"}, [node0]), h("div", {"className": "display"}, [...conditionalElements0])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.toggle !== currentInput.toggle) {
        node0["onclick"] = input.toggle;
      }
      if (input.show !== currentInput.show) {
        let newRoot0;
        if (input.show) {
          const newState = child0(input);
          newRoot0 = newState.root;
        } else {
          const newState = child1(input);
          newRoot0 = newState.root;
        }
        currentRoot0.replaceWith(newRoot0);
        currentRoot0 = newRoot0;
      } else {
        currentRoot0.update(input);
      }
      currentInput = input;
    }
  };
}
