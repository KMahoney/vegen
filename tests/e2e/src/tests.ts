// Generated by VeGen. Do not edit.

function h<K extends keyof HTMLElementTagNameMap>(
  tag: K,
  props: Partial<HTMLElementTagNameMap[K]> = {},
  children: Node[] = [],
  dataset: Record<string, string> = {}
): HTMLElementTagNameMap[K] {
  const element = document.createElement(tag);
  Object.assign(element, props);
  Object.assign(element.dataset, dataset);
  element.append(...children);
  return element;
}
const t = (s: string) => document.createTextNode(s);

// Builtin functions
function numberToString(value: number): string {
  return value.toString();
}
function boolean<T>(value: boolean, t: T, f: T): T {
  return value ? t : f;
}
function lookup<V>(m: { [k: string]: V }, k: string, d: V) {
  return m[k] ?? d;
}

type ViewState<Input> = {
  root: any;
  update: (input: Input) => void;
};
type View<Input> = (input: Input) => ViewState<Input>;
function updateForLoop<Input>({
  anchor,
  prevStates,
  nextInputs,
  subView,
}: {
  anchor: Comment;
  prevStates: ViewState<Input>[];
  nextInputs: Input[];
  subView: View<Input>;
}) {
  const parent = anchor.parentNode!;
  let states = prevStates.slice();

  // Remove extra items (from end, working backwards)
  while (states.length > nextInputs.length) {
    const removed = states.pop()!;
    parent.removeChild(removed.root);
  }

  // Update existing items
  for (let i = 0; i < Math.min(states.length, nextInputs.length); i++) {
    states[i].update(nextInputs[i]);
  }

  // Add new items (insert before anchor)
  for (let i = states.length; i < nextInputs.length; i++) {
    const state = subView(nextInputs[i]);
    parent.insertBefore(state.root, anchor);
    states.push(state);
  }

  return states;
}
export function run<Input>(
  view: View<Input>,
  buildComponent: (
    get: () => Input,
    set: (stateUpdater: Input | ((current: Input) => Input)) => void
  ) => Input
): Element {
  let state: ViewState<Input>;
  let currentInput: Input;

  const get = () => currentInput;

  const set = (stateUpdater: Input | ((current: Input) => Input)) => {
    currentInput =
      typeof stateUpdater === "function"
        ? (stateUpdater as (current: Input) => Input)(currentInput)
        : stateUpdater;
    state.update(currentInput);
  };

  // Build the initial input and state
  currentInput = buildComponent(get, set);
  state = view(currentInput);

  return state.root;
}
export type ComponentInput = { counter: () => Element, total: number };
export function Component(input: ComponentInput): ViewState<ComponentInput> {
  const mountedElement0 = input.counter();
  const mountedElement1 = input.counter();
  const node0 = t(numberToString(input.total));
  const root = h("div", {"className": "container"}, [h("div", {"className": "grid"}, [mountedElement0, mountedElement1]), h("div", {"className": "highlight"}, [t("\n      Total Count: "), node0, t("\n    ")])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.total !== currentInput.total) {
        node0.textContent = numberToString(input.total);
      }
      currentInput = input;
    }
  };
}
export type CounterInput = { count: number, decrement: (this: GlobalEventHandlers, ev: MouseEvent) => any, increment: (this: GlobalEventHandlers, ev: MouseEvent) => any };
export function Counter(input: CounterInput): ViewState<CounterInput> {
  const node0 = t(numberToString(input.count));
  const node1 = h("button", {"onclick": input.increment}, [t("+ Increment")]);
  const node2 = h("button", {"onclick": input.decrement}, [t("- Decrement")]);
  const root = h("div", {"className": "container"}, [h("div", {"className": "display"}, [t("Count: "), node0]), h("div", {"className": "controls"}, [node1, node2])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.count !== currentInput.count) {
        node0.textContent = numberToString(input.count);
      }
      if (input.decrement !== currentInput.decrement) {
        node2["onclick"] = input.decrement;
      }
      if (input.increment !== currentInput.increment) {
        node1["onclick"] = input.increment;
      }
      currentInput = input;
    }
  };
}
export type IfTestInput = { a: { b: { c: string } }, show: boolean, toggle: (this: GlobalEventHandlers, ev: MouseEvent) => any, x: { y: { z: string } } };
export function IfTest(input: IfTestInput): ViewState<IfTestInput> {
  const child0: View<any> = (input) => {
    const node0 = t(input.a.b.c);
    const root = h("div", {"id": "shown"}, [t("Now you see me! "), node0]);
    let currentInput = input;
    return {
      root,
      update(input) {
        if (input.a.b.c !== currentInput.a.b.c) {
          node0.textContent = input.a.b.c;
        }
        currentInput = input;
      }
    };
  };
  const child1: View<any> = (input) => {
    const node0 = t(input.x.y.z);
    const root = h("div", {"id": "hidden"}, [t("Now you don't! "), node0]);
    let currentInput = input;
    return {
      root,
      update(input) {
        if (input.x.y.z !== currentInput.x.y.z) {
          node0.textContent = input.x.y.z;
        }
        currentInput = input;
      }
    };
  };
  let currentState0: ViewState<any>;
  if (input.show) {
    currentState0 = child0(input);
  } else {
    currentState0 = child1(input);
  }
  const conditionalElement0 = currentState0.root;
  const node0 = h("button", {"onclick": input.toggle}, [t("Toggle")]);
  const root = h("div", {"className": "container"}, [h("div", {"className": "controls"}, [node0]), h("div", {"className": "display"}, [conditionalElement0])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.toggle !== currentInput.toggle) {
        node0["onclick"] = input.toggle;
      }
      if (input.show !== currentInput.show) {
        let newState0: ViewState<any>;
        if (input.show) {
          newState0 = child0(input);
        } else {
          newState0 = child1(input);
        }
        const newRoot0 = newState0.root;
        currentState0.root.replaceWith(newRoot0);
        currentState0 = newState0;
      } else {
        currentState0.update(input);
      }
      currentInput = input;
    }
  };
}
export type NestedForInput = { addBar: (this: GlobalEventHandlers, ev: MouseEvent) => any, addFoo: (this: GlobalEventHandlers, ev: MouseEvent) => any, bars: string[], foos: string[] };
export function NestedFor(input: NestedForInput): ViewState<NestedForInput> {
  const child0: View<any> = (input) => {
    const child0: View<any> = (input) => {
      const node0 = t(input.foo);
      const node1 = t(input.bar);
      const node2 = h("div", {"className": "card", "id": `${input.foo}${input.bar}`}, [node0, t(" - "), node1]);
      const root = node2;
      let currentInput = input;
      return {
        root,
        update(input) {
          if (input.bar !== currentInput.bar) {
            node1.textContent = input.bar;
          }
          if (input.bar !== currentInput.bar || input.foo !== currentInput.foo) {
            node2["id"] = `${input.foo}${input.bar}`;
          }
          if (input.foo !== currentInput.foo) {
            node0.textContent = input.foo;
          }
          currentInput = input;
        }
      };
    };
    const anchor0 = document.createComment("for-loop-0");
    const loopElements0 = [];
    let childState0: any[] = [];
    for (const item of input.bars) {
      const itemState = child0({ ...input, bar: item });
      loopElements0.push(itemState.root);
      childState0.push(itemState);
    }
    loopElements0.push(anchor0);
    const root = h("div", {"className": "flex"}, [...loopElements0]);
    let currentInput = input;
    return {
      root,
      update(input) {
        childState0 = updateForLoop({
          anchor: anchor0,
          prevStates: childState0,
          nextInputs: input.bars.map((bar: any) => ({ ...input, bar })),
          subView: child0
        });
        currentInput = input;
      }
    };
  };
  const anchor0 = document.createComment("for-loop-0");
  const loopElements0 = [];
  let childState0: any[] = [];
  for (const item of input.foos) {
    const itemState = child0({ ...input, foo: item });
    loopElements0.push(itemState.root);
    childState0.push(itemState);
  }
  loopElements0.push(anchor0);
  const node0 = h("button", {"onclick": input.addFoo}, [t("+ Add Foo")]);
  const node1 = h("button", {"onclick": input.addBar}, [t("+ Add Bar")]);
  const root = h("div", {"className": "container"}, [h("div", {"className": "controls"}, [node0, node1]), h("div", {"className": "flex-column"}, [...loopElements0])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.addBar !== currentInput.addBar) {
        node1["onclick"] = input.addBar;
      }
      if (input.addFoo !== currentInput.addFoo) {
        node0["onclick"] = input.addFoo;
      }
      childState0 = updateForLoop({
        anchor: anchor0,
        prevStates: childState0,
        nextInputs: input.foos.map((foo: any) => ({ ...input, foo })),
        subView: child0
      });
      currentInput = input;
    }
  };
}
export type SwitchTestInput = { example: { foo: string, type: "a" } | { bar: string, type: "b" } | { baz: number, type: "c" }, toggleHandler: (this: GlobalEventHandlers, ev: MouseEvent) => any };
export function SwitchTest(input: SwitchTestInput): ViewState<SwitchTestInput> {
  const child0: View<any> = (input) => {
    const node0 = t(input.a.foo);
    const root = h("div", {}, [node0]);
    let currentInput = input;
    return {
      root,
      update(input) {
        if (input.a.foo !== currentInput.a.foo) {
          node0.textContent = input.a.foo;
        }
        currentInput = input;
      }
    };
  };
  const child1: View<any> = (input) => {
    const node0 = t(input.b.bar);
    const root = h("div", {}, [node0]);
    let currentInput = input;
    return {
      root,
      update(input) {
        if (input.b.bar !== currentInput.b.bar) {
          node0.textContent = input.b.bar;
        }
        currentInput = input;
      }
    };
  };
  const child2: View<any> = (input) => {
    const node0 = t(numberToString(input.c.baz));
    const root = h("div", {}, [node0]);
    let currentInput = input;
    return {
      root,
      update(input) {
        if (input.c.baz !== currentInput.c.baz) {
          node0.textContent = numberToString(input.c.baz);
        }
        currentInput = input;
      }
    };
  };
  let currentSwitchState0: ViewState<any>;
  const switchElement0 = (() => {
    const onValue = input.example.type;
    switch (onValue) {
      case "a": {
        const caseInput = { ...input, a: input.example };
        const st = child0(caseInput);
        currentSwitchState0 = st;
        return st.root;
      }
      case "b": {
        const caseInput = { ...input, b: input.example };
        const st = child1(caseInput);
        currentSwitchState0 = st;
        return st.root;
      }
      case "c": {
        const caseInput = { ...input, c: input.example };
        const st = child2(caseInput);
        currentSwitchState0 = st;
        return st.root;
      }
      default: {
        const st = { root: document.createComment("switch-empty"), update: (_: any) => {} };
        currentSwitchState0 = st;
        return st.root;
      }
    }
  })();
  const node0 = h("button", {"onclick": input.toggleHandler}, [t("Toggle")]);
  const root = h("div", {"className": "container"}, [node0, switchElement0]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.toggleHandler !== currentInput.toggleHandler) {
        node0["onclick"] = input.toggleHandler;
      }
      const newOnValue0 = input.example.type;
      const prevOnValue0 = currentInput.example.type;
      if (newOnValue0 !== prevOnValue0) {
        let newState0: ViewState<any>;
        let newRoot0: any;
        switch (newOnValue0) {
          case "a": {
            const caseInput = { ...input, a: input.example };
            newState0 = child0(caseInput);
            newRoot0 = newState0.root;
            break;
          }
          case "b": {
            const caseInput = { ...input, b: input.example };
            newState0 = child1(caseInput);
            newRoot0 = newState0.root;
            break;
          }
          case "c": {
            const caseInput = { ...input, c: input.example };
            newState0 = child2(caseInput);
            newRoot0 = newState0.root;
            break;
          }
          default: {
            newState0 = { root: document.createComment("switch-empty"), update: (_: any) => {} };
            newRoot0 = newState0.root;
          }
        }
        currentSwitchState0.root.replaceWith(newRoot0);
        currentSwitchState0 = newState0;
      } else {
        switch (newOnValue0) {
          case "a": {
            const caseInput = { ...input, a: input.example };
            currentSwitchState0.update(caseInput);
            break;
          }
          case "b": {
            const caseInput = { ...input, b: input.example };
            currentSwitchState0.update(caseInput);
            break;
          }
          case "c": {
            const caseInput = { ...input, c: input.example };
            currentSwitchState0.update(caseInput);
            break;
          }
          default: {
            // no-op
          }
        }
      }
      currentInput = input;
    }
  };
}
