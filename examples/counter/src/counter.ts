// Generated by VeGen. Do not edit.

function h<K extends keyof HTMLElementTagNameMap>(
  tag: K,
  props: Partial<HTMLElementTagNameMap[K]> = {},
  children: Node[] = [],
  dataset: Record<string, string> = {}
): HTMLElementTagNameMap[K] {
  const element = document.createElement(tag);
  Object.assign(element, props);
  Object.assign(element.dataset, dataset);
  element.append(...children);
  return element;
}
const t = (s: string) => document.createTextNode(s);

// Pipeline functions
function numberToString(value: number): string {
  return value.toString();
}
function boolean<T>(value: boolean, t: T, f: T): T {
  return value ? t : f;
}
type ViewState<Input> = {
  root: any;
  update: (input: Input) => void;
};
type View<Input> = (input: Input) => ViewState<Input>;
function updateForLoop<Input>({
  anchor,
  prevStates,
  nextInputs,
  subView,
}: {
  anchor: Comment;
  prevStates: ViewState<Input>[];
  nextInputs: Input[];
  subView: View<Input>;
}) {
  const parent = anchor.parentNode!;
  let states = prevStates.slice();

  // Remove extra items (from end, working backwards)
  while (states.length > nextInputs.length) {
    const removed = states.pop()!;
    parent.removeChild(removed.root);
  }

  // Update existing items
  for (let i = 0; i < Math.min(states.length, nextInputs.length); i++) {
    states[i].update(nextInputs[i]);
  }

  // Add new items (insert before anchor)
  for (let i = states.length; i < nextInputs.length; i++) {
    const state = subView(nextInputs[i]);
    parent.insertBefore(state.root, anchor);
    states.push(state);
  }

  return states;
}
export function run<Input>(
  view: View<Input>,
  buildComponent: (get: () => Input, set: (newInput: Input) => void) => Input
): Element {
  let state: ViewState<Input>;
  let currentInput: Input;

  const get = () => currentInput;

  const set = (newInput: Input) => {
    currentInput = newInput;
    state.update(newInput);
  };

  // Build the initial input and state
  currentInput = buildComponent(get, set);
  state = view(currentInput);

  return state.root;
}
export type CounterInput = { clickHandler: (this: GlobalEventHandlers, ev: MouseEvent) => any, count: number };
export function counter(input: CounterInput): ViewState<CounterInput> {
  const node0 = t(numberToString(input.count));
  const node1 = h("button", {"onclick": input.clickHandler}, [t("Clicked "), node0, t(" times")]);
  const root = h("div", {}, [h("h1", {}, [t("Counter example")]), h("div", {}, [node1])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.clickHandler !== currentInput.clickHandler) {
        node1["onclick"] = input.clickHandler;
      }
      if (input.count !== currentInput.count) {
        node0.textContent = numberToString(input.count);
      }
      currentInput = input;
    }
  };
}
