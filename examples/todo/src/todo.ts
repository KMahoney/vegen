// Generated by VeGen. Do not edit.

function h<K extends keyof HTMLElementTagNameMap>(
  tag: K,
  props: Partial<HTMLElementTagNameMap[K]> = {},
  children: Node[] = [],
  dataset: Record<string, string> = {}
): HTMLElementTagNameMap[K] {
  const element = document.createElement(tag);
  Object.assign(element, props);
  Object.assign(element.dataset, dataset);
  element.append(...children);
  return element;
}
const t = (s: string) => document.createTextNode(s);

// Builtin functions
function numberToString(value: number): string {
  return value.toString();
}
function boolean<T>(value: boolean, t: T, f: T): T {
  return value ? t : f;
}
function lookup<V>(m: { [k: string]: V }, k: string, d: V) {
  return m[k] ?? d;
}

type ViewState<Input> = {
  root: any;
  update: (input: Input) => void;
};
type View<Input> = (input: Input) => ViewState<Input>;
function updateForLoop<Input>({
  anchor,
  prevStates,
  nextInputs,
  subView,
}: {
  anchor: Comment;
  prevStates: ViewState<Input>[];
  nextInputs: Input[];
  subView: View<Input>;
}) {
  const parent = anchor.parentNode!;
  let states = prevStates.slice();

  // Remove extra items (from end, working backwards)
  while (states.length > nextInputs.length) {
    const removed = states.pop()!;
    parent.removeChild(removed.root);
  }

  // Update existing items
  for (let i = 0; i < Math.min(states.length, nextInputs.length); i++) {
    states[i].update(nextInputs[i]);
  }

  // Add new items (insert before anchor)
  for (let i = states.length; i < nextInputs.length; i++) {
    const state = subView(nextInputs[i]);
    parent.insertBefore(state.root, anchor);
    states.push(state);
  }

  return states;
}
export function run<Input>(
  view: View<Input>,
  buildComponent: (
    get: () => Input,
    set: (stateUpdater: Input | ((current: Input) => Input)) => void
  ) => Input
): Element {
  let state: ViewState<Input>;
  let currentInput: Input;

  const get = () => currentInput;

  const set = (stateUpdater: Input | ((current: Input) => Input)) => {
    currentInput =
      typeof stateUpdater === "function"
        ? (stateUpdater as (current: Input) => Input)(currentInput)
        : stateUpdater;
    state.update(currentInput);
  };

  // Build the initial input and state
  currentInput = buildComponent(get, set);
  state = view(currentInput);

  return state.root;
}
export type TodoInput = { addTodoHandler: (this: GlobalEventHandlers, ev: MouseEvent) => any, completedCount: number, deleteHandler: (v0: any) => (this: GlobalEventHandlers, ev: MouseEvent) => any, handleKeyPress: (this: GlobalEventHandlers, ev: KeyboardEvent) => any, newTodoText: string, todos: { completed: boolean, id: any, text: string }[], toggleHandler: (v0: any) => (this: GlobalEventHandlers, ev: Event) => any, totalCount: number, updateNewTodoText: (this: GlobalEventHandlers, ev: Event) => any };
export function Todo(input: TodoInput): ViewState<TodoInput> {
  const child0: View<any> = (input) => {
    const node0 = h("input", {"type": "checkbox", "checked": input.todo.completed, "onchange": input.toggleHandler(input.todo.id)}, []);
    const node1 = t(input.todo.text);
    const node2 = h("button", {"type": "button", "onclick": input.deleteHandler(input.todo.id), "className": "delete-btn"}, [t("Delete")]);
    const node3 = h("li", {"className": boolean(input.todo.completed, `completed`, ``)}, [node0, h("span", {"className": "todo-text"}, [node1]), node2]);
    const root = node3;
    let currentInput = input;
    return {
      root,
      update(input) {
        if (input.deleteHandler !== currentInput.deleteHandler || input.todo.id !== currentInput.todo.id) {
          node2["onclick"] = input.deleteHandler(input.todo.id);
        }
        if (input.todo.completed !== currentInput.todo.completed) {
          node0["checked"] = input.todo.completed;
          node3["className"] = boolean(input.todo.completed, `completed`, ``);
        }
        if (input.todo.id !== currentInput.todo.id || input.toggleHandler !== currentInput.toggleHandler) {
          node0["onchange"] = input.toggleHandler(input.todo.id);
        }
        if (input.todo.text !== currentInput.todo.text) {
          node1.textContent = input.todo.text;
        }
        currentInput = input;
      }
    };
  };
  const anchor0 = document.createComment("for-loop-0");
  const loopElements0 = [];
  let childState0: any[] = [];
  for (const item of input.todos) {
    const itemState = child0({ ...input, todo: item });
    loopElements0.push(itemState.root);
    childState0.push(itemState);
  }
  loopElements0.push(anchor0);
  const node0 = h("input", {"type": "text", "placeholder": "Add a new todo...", "value": input.newTodoText, "oninput": input.updateNewTodoText, "onkeypress": input.handleKeyPress}, []);
  const node1 = h("button", {"type": "button", "onclick": input.addTodoHandler}, [t("Add Todo")]);
  const node2 = t(numberToString(input.totalCount));
  const node3 = t(numberToString(input.completedCount));
  const root = h("div", {}, [h("h1", {"className": "b"}, [t("Todo App")]), h("div", {"className": "add-todo"}, [node0, node1]), h("div", {"className": "todo-list"}, [h("ul", {}, [...loopElements0])]), h("div", {"className": "todo-stats"}, [h("p", {}, [t("Total todos: "), node2]), h("p", {}, [t("Completed: "), node3])])]);
  let currentInput = input;
  return {
    root,
    update(input) {
      if (input.addTodoHandler !== currentInput.addTodoHandler) {
        node1["onclick"] = input.addTodoHandler;
      }
      if (input.completedCount !== currentInput.completedCount) {
        node3.textContent = numberToString(input.completedCount);
      }
      if (input.handleKeyPress !== currentInput.handleKeyPress) {
        node0["onkeypress"] = input.handleKeyPress;
      }
      if (input.newTodoText !== currentInput.newTodoText) {
        node0["value"] = input.newTodoText;
      }
      if (input.totalCount !== currentInput.totalCount) {
        node2.textContent = numberToString(input.totalCount);
      }
      if (input.updateNewTodoText !== currentInput.updateNewTodoText) {
        node0["oninput"] = input.updateNewTodoText;
      }
      childState0 = updateForLoop({
        anchor: anchor0,
        prevStates: childState0,
        nextInputs: input.todos.map((todo: any) => ({ ...input, todo })),
        subView: child0
      });
      currentInput = input;
    }
  };
}
